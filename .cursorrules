# Cursor AI Rules for Identity API Database Migration Project

## Project Context
This is the identity-api service working on robust database migration and SQL query testing (IDE-904 spike).

## General rules
- If I write "Start" ask for the ticket id.
- Whenever there is a command to run, do not ask the user if they want to either run it or not, instead prepare the command and set the "run" button.
- If you execute a command, always provide a brief about what you need to achieve to understand what the command does. Always explain what you're doing, at least a small brief.
- If any document is updated, be sure to update their corresponding index.
- Explain when running commands, what they do.

## Documentation Process
- After ticket provided ask for the ticket information to have context.
- After context provided ask any questions if needed, ask one question at a time and wait for each answer. Max 10 questions top so be sure all that needs to be clear is within those questions. Do not forget the questions, even if the user changes topics, you can answer that and go back to the questions.
- Create a folder and name it after the ticket id provided.
- Once everything is clear proceed to create a readme document within the folder with the ticket Id. Name the file as Readme.md
- Wait for review and expect approval or feedback. Update the document if feedback provided.
- Once approved, create another document within the folder for the ticket id to setup the phases for development and name it "Development Phases.md". Put dependant phases at the end of the process. Besides add an index to the document with up to 3 sublevels.
- Wait for review and expect approval or feedback.
- After readme and Development Phases docs are created and approved, ask if there is something else that needs to be added. Otherwhise ask if it's ok to start with the development phases. Besides add an index to the document.
- Do not implement anything until it's requested, only work on the documents.
- If there is feedback and any document is updated, look for all documents and update any reference for that specific change. The idea is having all documents synced up and accurately reflecting all changes.

## Development
- Base on the readme and phases documents, start development one phase at a time, starting from phase 1.
- Once phase one is done, wait for approval
- Once all phases are done, give one overall review to all changes and let me know if there's something to change/improve/tweak.
- After no more changes required, ask if you could start with the unit tests.

## Testing Rules
- For tests use map[string]struct instead of arrays
- Implement tests for every possible flow of the new implementation done.
- Test all new unit tests and verify they all pass.
- Test the rest of the other test to check all of them pass too.

## Naming Conventions
- Do not add unit tests until requested. They would give some noise and might have to be changed if code changes, so let's leave them at the end.
- Test files: *_test.go
- Functions: camelCase with clear purpose indication

## Compilation and Code Quality Rules
- ALWAYS verify there are no compilation errors before proceeding with any changes
- Run `go build .` in each service directory to ensure clean compilation
- Check for any syntax errors, missing imports, or undefined references
- If compilation fails, fix the errors before making any other changes
- Verify that all Go files compile successfully in the target service directory

## Service Consistency Rules
- ALWAYS compare with existing working services when implementing new APIs or UI components
- Study the patterns used in working services (gateway, session, inventory, orders, invoice)
- Follow the same architectural patterns, naming conventions, and code structure
- Ensure new implementations match the existing service patterns exactly
- Use the same middleware, error handling, and response formats as existing services
- Maintain consistency in API endpoints, HTTP methods, and request/response structures
- ALWAYS look at existing working services or UI pages to follow the same pattern in new ones or the ones not working
- Copy the exact working patterns from functional components instead of reinventing solutions

## API Access Rules
- NEVER make direct API calls to individual services (session, orders, inventory, invoice)
- ALL API calls MUST go through the gateway service (port 8082)
- Direct service access is PROHIBITED and will be blocked by the services
- Use gateway endpoints for all testing, debugging, and API interactions
- Gateway is the single point of entry for all external API requests

## Data Integrity and Security Rules
- ALL date/timestamp fields (created_at, updated_at, transaction_date, expiration_date, etc.) MUST be set server-side
- NEVER trust client-provided dates for audit trails, creation timestamps, or security-sensitive operations
- Server should set current timestamp as default when no date is provided
- Client-side date setting is PROHIBITED for security and data integrity
- All timestamps should be in UTC and handled consistently across services

## Authentication Rules
- All business endpoints MUST require authentication except:
  - Health check endpoints (`/health`, `/p/health`)
  - Authentication endpoints (`/login`, `/validate`, `/logout`)
  - Public session endpoints (`/p/login`, `/p/validate`)
- Gateway handles all authentication validation using session middleware
- Individual services (orders, inventory, invoice) do NOT implement authentication middleware
- Gateway forwards user context headers (X-User-ID, X-Username, X-User-Role, X-User-Permissions) to downstream services
- UI must include proper authentication headers in all API calls
- Services should trust user context headers from gateway

## Service Access Rules
- ALL service access MUST go through the gateway service
- Direct access to individual services (session, orders, inventory, invoice) is PROHIBITED
- Services should block direct access and require gateway headers
- Gateway is the single point of entry for all API requests
- Health checks and monitoring should go through gateway endpoints
- Internal service-to-service communication is ALLOWED when proper gateway headers are included
- Services should include gateway headers (X-Gateway-Service, X-Gateway-Session-Managed) for internal calls

## UI Foreign Key Selection Rules
- ALL foreign key fields in UI forms MUST use "Select..." pattern with search functionality
- Replace direct ID inputs with display field + hidden ID field + search button
- Implement picker modals for all FK selections (suppliers, categories, etc.)
- Follow the exact pattern from working pages (suppliers, ingredients)
- Include search functionality in picker modals
- Use consistent naming: `open[Entity]Picker()`, `select[Entity]()`, `filter[Entity]()`
- Load active/valid records only in picker modals
- Provide clear visual feedback for selected items

## UI Image Control Rules
- ALL image fields in UI forms MUST include image upload/selection controls
- Replace direct URL inputs with file input + preview + upload functionality
- Implement image preview before upload
- Include drag-and-drop functionality for better UX
- Support common image formats (JPG, PNG, GIF, WebP)
- Provide clear feedback for upload progress and success/error states
- Use consistent naming: `openImagePicker()`, `uploadImage()`, `previewImage()`
- Validate file size and format on client-side before upload
- Show image preview with option to remove/replace 